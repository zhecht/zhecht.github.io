<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Zhecht.GitHub.io : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Zhecht.GitHub.io</title>
  </head>
  <style>
    sup {font-size:xx-small; vertical-align:super;}
  </style>
  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/zhecht">View on GitHub</a>

          <h1 id="project_title">Quantum Physics</h1>
          <h2 id="project_tagline">The End of Modern Cryptography?</h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Short Answer? No Way</h3>

<p>In the news, you can find numerous articles with titles similar to the likes of <a href="https://news.mit.edu/2016/quantum-computer-end-encryption-schemes-0303">The beginning of the end for encryption schemes?</a>. This is somewhat counter-intuitive though. Numerous algorithms used in the real-world will become obselete once quantum computers are introduced into our lifes. On the other hand, over enough time, a plethora of new encryption schemes will be created. So the problem we face today...do we have enough time to prepare for the inevitable.</p>

<h3>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Mosca Theorem</h3>

<p>Michele Mosca proposed a simple theorem with huge implications. He defines <code>x</code> as the time (in years) it will take for encryption to become secure, <code>y</code> is how long it will take to re-tool existing infrastructures with quantum safe solutions, and lastly <code>z</code>, how long it will take until a large-scale quantum computer is built.</p>

<p style="text-align:center;">If <code>x + y > z</code>, worry.</p>

<p>NIST and other experts expect that a quantum computer will be built within <strong>15 years</strong>. Many security companies and intelligent angencies are well on their way to implementing post-quantum standards. These are schemes that, in theory, are unbreakable even with the use of a quantum computer.</p>
<h3>
<a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Time For A Change</h3>

<p>All public key crypto (RSA, DSA, Diffie-Hellman exchange) will be vulnerable to attacks. Symmetric key cryptography (AES) and Hash functions (SHA-1,2,3) would need a modification that can affect runtime and memory. Symmetric key crypto would need larger keys and hash functions would need longer outputs. Public key cryptography together with quantum-resitant algorithms can fix our problem. </p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quantum-Resistant Algorithms</h3>

<p>
  <ul>
    <li>Secret-Key Crypto (AES)</li>
    <li>Multivariate-quadratic equations</li>
    <li>Lattice-Based (NTRU)</li>
    <li>Code-Based (McEliece)</li>
    <li>Hash-Based (Merkle's Tree)</li>
  </ul>
  In theory, these algorithms are thought to be safe from an adversary equipped with a quantum computer. The reason public key cryptography works in practice is due to three properties. 1) Integer Factorization Problem, 2) Discrete Log Problem, 3) Elliptic-Curve Discrete Log Problem. Scientists have shown that with the help of a quantum computer, all these problems can be easily solved in feasible time. Peter Shor introduced the Shor algorithm in 1994, shocking the world of computer science.
</p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Shor's Algorithm</h3>

<p>The Shor algorithm factors large integers in polynomial time, thus making RSA insecure. The fastest known scheme to break RSA at the time was called the number-field sieve. The number-field sieve, presented in 1988, still has a runtime similar to algorithms presented today. It can factor any RSA % n using 2<sup>(1.9...+o(1))(lg n)^(1/3) (lg lg n)^(2/3)</sup> operations. 6 years later and Shor presented that a quantum computer of size (lg n)<sup>1+o(1)</sup> can factor RSA % n in only (lg n)<sup>2+o(1)</sup> operations.</p>

<p>Before we get into an example of how Shor's works, we need to clear up some layman quantum terms for the beginners (like me).</p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Definitions</h3>

<p>
<ul>
<li><strong>Quantum Bit (Qubit):</strong> Like a bit, a qubit holds information. According to the no-cloning theorem and no-deleting theorem, a qubit's information cannot be copied nor destroyed. A qubit can exist not only in 0 and 1 states (like a bit), but also any combination of the two. <sub>**</sub>CAVEAT: Once the system is observed, the qubit's state collapses into one of its basis states (0,1)<sub>**</sub></li>

<li><strong>Quantum Superposition:</strong> Two quantum states can be added together to create another valid quantum state. <sub>**</sub>Every quantum state can be represented as a sum of two or more other distinct states<sub>**</sub>.</li>

<li><strong>Quantum Parallelism:</strong> A register of n qubits will have 2<sub>n</sub> basis states of its own. Since a register can exist in a superposition of all these states at once, it is possible to apply a computation to all 2<sub>n</sub> register states rather than just one.</li>

<li><strong>Modular Period:</strong> Say set = {2,4,8,16,32,64,..} ; set (mod 15) = {2,4,8,1,2,4,8,1,..} ; The period would be 4.</li>
</ul>
</p>

<h3>
  <a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>Shor's Pseudocode</a></h3>

<p>
The algorithm consists of two steps.<br>
a) Turns the factoring into the period finding problem <br>
b) Finds period using quantum fourier transform  <br><br>

Factoring a large odd integer N<br>
1)Choose random m &lt; N. Compute gcd(m,N) using Euclideans which runs in poly-time. If gcd(m,N) &neq; 1, we have found a non-trivial factor and are finished. <br>
2) Use quantum computer to determine unknown period P with probability close to 1<br>
3) If P is odd, return to step 1 ; Else, proceed. The Pr[P is odd] = (1/2)<sub>k</sub>, where k is the number of distinct prime factors of N.<br>
4) Note: (m<sub>P/2</sub> - 1)(m<sub>P/2</sub> + 1) = m<sub>P</sub> - 1 <br>
If m<sub>P/2</sub> + 1 = 0 (mod N), return to step 1 ; Else, Proceed. Pr[m<sub>P/2</sub> + 1 = 0 (mod N)] &lt; (1/2)<sub>k-1</sub> <br>
5) Compute d = gcd(m<sub>P/2</sub> - 1, N) with Euclidean. Since m<sub>P/2</sub> + 1 &neq; 0 (mod N), it is shown that d is non-trivial factor of N.

</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
